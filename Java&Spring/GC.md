# 가비지 컬렉션
- 자바 이전에는 프로그래머가 모든 프로그램 메모리를 관리했다.
- 하지만 자바는 JVM이 가비지 컬렉션이라는 프로세스를 통해 프로그램 메모리를 관리한다.
- Heap 영역에서 동적으로 할당했던 메모리 중 필요없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스
##### 장점
- 개발자는 개발에만 집중할 수 있게 되었다.
##### 단점
- 가비지 컬렉션이 동작하는 동안 다른 동작을 멈추기 때문에 오버헤드가 발생
## Stop the world
- GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것
- **GC 튜닝은 이 stop the world 시간을 줄이는 것**
## GC의 대상
1. 객체가 NULL인 경우
2. 블럭 실행 종료 후, 블럭 안에서 생성된 객체
3. 부모 객체가 NULL인 경우, 포함하는 자식 객체
## GC의 청소 방식
### Mark and Sweep
- GC에서 사용되는 객체를 솎아내는 내부 알고리즘
- 기초적인 청소 과정
- 가비지 컬렉션이 될 대상 객체를 식별(Mark) 하고 제거(Sweep) 하며 객체가 제거되어 파편화된 메모리 영역을 앞에서부터 채워나가는 과정(Compaction)을 수행 
  
![[Pasted image 20230919032453.png]]
#### mark 과정
- Root Space로부터 그래프 순회를 통해 연결된 객체들을 찾아내어 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다.
#### Sweep 과정
- 참조하고 있지 않은 객체 즉 Unreachable 객체들을 Heap에서 제거한다.
#### Compact 과정
- Sweep 후에 분산된 객체들을 Heap의 시작 주소로 모아 메모리가 할당된 부분과 그렇지 않은 부분으로 압축한다.
## Heap 메모리의 구조
- JVM의 heap 영역은 동적으로 레퍼런스 데이터가 저장되는 공간으로, 가비지 컬렉션에 대상이 되는 공간이다.
	- [[JVM]]
- Heap 영역은 처음 설계될 때 다음의 2가지 전제로 설계 되었다.
	- 대부분의 객체는 금방 접근 불가능한 상태가 된다.
	- 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.
- ["] **즉 객체는 대부분 일회성이며, 메모리에 오랫동안 남아있는 경우는 드물다**
- 객체의 생존 기간에 따라 물리적인 Heap 영역을 나누게 되었고 
	- Young, Old 총 2가지 영역으로 설계하였다.

![[Pasted image 20230919033942.png]]
### Young 영역
- 새롭게 생성된 객체가 할당되는 영역
- 대부분의 객체가 금방 Unreachable 상태가 되기 때문에 많은 객체가 Young 영역에 생성되었다가 사라진다.
- Young 영역에 대한 가비지 컬렉션을 **Minor GC**라고 부른다.
- 또 다시 힙 영역은 효율적인 GC를 위해 Young 영역을 3가지 영역으로 나눈다.
#### Eden
- new를 통해 새로 생성된 객체가 위치
- 정기적인 쓰레기 수집 후 살아남은 객체들은 Survivor 영역으로 보냄
#### Survivor 0 / Survivor 1
- 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역
- Survivor 영역에는 특별한 규칙이 있다.
	- 둘 중 하나는 꼭 비어 있어야 한다.
*이렇게 객체의 생존 기간을 면밀히 제어하여 정확하게 불필요한 객체를 제거하는 프로세스를 실행하도록 한다.*
### Old 영역
- Young 영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역
- Young 영역보다 크게 할당되며, 영역의 크기가 큰 만큼 가비지는 적게 발생한다.
- Old 영역에 대한 가비지 컬렉션을 **Major GC** 또는 Full GC라고 부른다.
## Minor GC 과정
- Young 영역은 짧게 살아남는 메모리들이 존재하는 공간
- 모든 객체는 해당 공간에 생성
- Old 영역에 비해 작기 때문에 적은 시간이 걸린다.
  
1. 처음 생성된 객체는 Eden 영역에 위치
2. Eden 영역이 꽉차게 되면 Minor GC가 실행
3. Mark 동작을 통해 reachable 객체를 탐색
4. 살아남은 객체는 1개의 Survivor 영역으로 이동
5. 사용되지 않는 객체의 메모리를 Sweep
6. 살아남은 모든 객체들은 age 값이 1씩 증가
7. 또다시 Eden 영역에 신규 객체들로 가득 차게 된다면 Minor GC가 발생하고 mark
8. marking 한 객체들을 비어있는 Survivor 1로 이동하고 Sweep
9. 살아남은 객체들은 age 값이 1씩 증가
10. 이러한 과정을 반복 
## Major GC 과정
- Old 영역은 길게 살아남는 메모리들이 존재하는 공간
- 처음에는 Young 영역에서 생성되었지만 GC 과정 중에 제거되지 않은 경우 age 임계값이 차게되어 이동된 객체들이 모임.
- 객체들이 계속 Promotion되어 Old 영역의 메모리가 부족해지면 발생
	- [I] Promotion 
		임계값에 도달한 객체가 Old 영역으로 이동되는 현상

1. 객체의 age가 임계값에 도달
2. Old 영역으로 이동 ( Promotion )
3. 위의 과정이 반복되어 **메모리가 부족하게 되면 Major GC** 발생

- 영역이 넓기 때문에 많은 시간이 걸린다.
## GC 알고리즘 종류
### G1 GC
- Java 9 버전의 디폴트 GC
- Region이라는 개념을 도입
- Eden, Survivor, Old 역할을 고정이 아닌 동적으로 부여
- GC 빈도가 줄어드는 효과를 얻음
- **메모리가 많이 차있는 영역을 인식하여 메모리가 많이 차있는 영역을 우선적으로 GC 한다.**
### ZGC
- java 15에 release
- 대량의 메모리를 low-latency로 잘 처리하기 위해 디자인 된 GC
- **stop the world의 시간이 절대 10ms를 넘지 않는다.**
